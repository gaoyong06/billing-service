// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: billing.proto

package v1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on GetAccountRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetAccountRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetAccountRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetAccountRequestMultiError, or nil if none found.
func (m *GetAccountRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetAccountRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for UserId

	if len(errors) > 0 {
		return GetAccountRequestMultiError(errors)
	}

	return nil
}

// GetAccountRequestMultiError is an error wrapping multiple validation errors
// returned by GetAccountRequest.ValidateAll() if the designated constraints
// aren't met.
type GetAccountRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetAccountRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetAccountRequestMultiError) AllErrors() []error { return m }

// GetAccountRequestValidationError is the validation error returned by
// GetAccountRequest.Validate if the designated constraints aren't met.
type GetAccountRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetAccountRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetAccountRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetAccountRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetAccountRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetAccountRequestValidationError) ErrorName() string {
	return "GetAccountRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetAccountRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetAccountRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetAccountRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetAccountRequestValidationError{}

// Validate checks the field values on GetAccountReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetAccountReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetAccountReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetAccountReplyMultiError, or nil if none found.
func (m *GetAccountReply) ValidateAll() error {
	return m.validate(true)
}

func (m *GetAccountReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for UserId

	// no validation rules for Balance

	for idx, item := range m.GetQuotas() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetAccountReplyValidationError{
						field:  fmt.Sprintf("Quotas[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetAccountReplyValidationError{
						field:  fmt.Sprintf("Quotas[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetAccountReplyValidationError{
					field:  fmt.Sprintf("Quotas[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetAccountReplyMultiError(errors)
	}

	return nil
}

// GetAccountReplyMultiError is an error wrapping multiple validation errors
// returned by GetAccountReply.ValidateAll() if the designated constraints
// aren't met.
type GetAccountReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetAccountReplyMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetAccountReplyMultiError) AllErrors() []error { return m }

// GetAccountReplyValidationError is the validation error returned by
// GetAccountReply.Validate if the designated constraints aren't met.
type GetAccountReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetAccountReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetAccountReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetAccountReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetAccountReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetAccountReplyValidationError) ErrorName() string { return "GetAccountReplyValidationError" }

// Error satisfies the builtin error interface
func (e GetAccountReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetAccountReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetAccountReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetAccountReplyValidationError{}

// Validate checks the field values on FreeQuota with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *FreeQuota) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FreeQuota with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in FreeQuotaMultiError, or nil
// if none found.
func (m *FreeQuota) ValidateAll() error {
	return m.validate(true)
}

func (m *FreeQuota) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ServiceName

	// no validation rules for TotalQuota

	// no validation rules for UsedQuota

	// no validation rules for ResetMonth

	if len(errors) > 0 {
		return FreeQuotaMultiError(errors)
	}

	return nil
}

// FreeQuotaMultiError is an error wrapping multiple validation errors returned
// by FreeQuota.ValidateAll() if the designated constraints aren't met.
type FreeQuotaMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FreeQuotaMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FreeQuotaMultiError) AllErrors() []error { return m }

// FreeQuotaValidationError is the validation error returned by
// FreeQuota.Validate if the designated constraints aren't met.
type FreeQuotaValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FreeQuotaValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FreeQuotaValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FreeQuotaValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FreeQuotaValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FreeQuotaValidationError) ErrorName() string { return "FreeQuotaValidationError" }

// Error satisfies the builtin error interface
func (e FreeQuotaValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFreeQuota.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FreeQuotaValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FreeQuotaValidationError{}

// Validate checks the field values on RechargeRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *RechargeRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RechargeRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RechargeRequestMultiError, or nil if none found.
func (m *RechargeRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *RechargeRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for UserId

	// no validation rules for Amount

	// no validation rules for PaymentMethod

	if len(errors) > 0 {
		return RechargeRequestMultiError(errors)
	}

	return nil
}

// RechargeRequestMultiError is an error wrapping multiple validation errors
// returned by RechargeRequest.ValidateAll() if the designated constraints
// aren't met.
type RechargeRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RechargeRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RechargeRequestMultiError) AllErrors() []error { return m }

// RechargeRequestValidationError is the validation error returned by
// RechargeRequest.Validate if the designated constraints aren't met.
type RechargeRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RechargeRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RechargeRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RechargeRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RechargeRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RechargeRequestValidationError) ErrorName() string { return "RechargeRequestValidationError" }

// Error satisfies the builtin error interface
func (e RechargeRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRechargeRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RechargeRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RechargeRequestValidationError{}

// Validate checks the field values on RechargeReply with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RechargeReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RechargeReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RechargeReplyMultiError, or
// nil if none found.
func (m *RechargeReply) ValidateAll() error {
	return m.validate(true)
}

func (m *RechargeReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for OrderId

	// no validation rules for PaymentUrl

	if len(errors) > 0 {
		return RechargeReplyMultiError(errors)
	}

	return nil
}

// RechargeReplyMultiError is an error wrapping multiple validation errors
// returned by RechargeReply.ValidateAll() if the designated constraints
// aren't met.
type RechargeReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RechargeReplyMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RechargeReplyMultiError) AllErrors() []error { return m }

// RechargeReplyValidationError is the validation error returned by
// RechargeReply.Validate if the designated constraints aren't met.
type RechargeReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RechargeReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RechargeReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RechargeReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RechargeReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RechargeReplyValidationError) ErrorName() string { return "RechargeReplyValidationError" }

// Error satisfies the builtin error interface
func (e RechargeReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRechargeReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RechargeReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RechargeReplyValidationError{}

// Validate checks the field values on ListRecordsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListRecordsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListRecordsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListRecordsRequestMultiError, or nil if none found.
func (m *ListRecordsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListRecordsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for UserId

	// no validation rules for Page

	// no validation rules for PageSize

	if len(errors) > 0 {
		return ListRecordsRequestMultiError(errors)
	}

	return nil
}

// ListRecordsRequestMultiError is an error wrapping multiple validation errors
// returned by ListRecordsRequest.ValidateAll() if the designated constraints
// aren't met.
type ListRecordsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListRecordsRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListRecordsRequestMultiError) AllErrors() []error { return m }

// ListRecordsRequestValidationError is the validation error returned by
// ListRecordsRequest.Validate if the designated constraints aren't met.
type ListRecordsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListRecordsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListRecordsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListRecordsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListRecordsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListRecordsRequestValidationError) ErrorName() string {
	return "ListRecordsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListRecordsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListRecordsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListRecordsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListRecordsRequestValidationError{}

// Validate checks the field values on ListRecordsReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ListRecordsReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListRecordsReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListRecordsReplyMultiError, or nil if none found.
func (m *ListRecordsReply) ValidateAll() error {
	return m.validate(true)
}

func (m *ListRecordsReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetRecords() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListRecordsReplyValidationError{
						field:  fmt.Sprintf("Records[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListRecordsReplyValidationError{
						field:  fmt.Sprintf("Records[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListRecordsReplyValidationError{
					field:  fmt.Sprintf("Records[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Total

	if len(errors) > 0 {
		return ListRecordsReplyMultiError(errors)
	}

	return nil
}

// ListRecordsReplyMultiError is an error wrapping multiple validation errors
// returned by ListRecordsReply.ValidateAll() if the designated constraints
// aren't met.
type ListRecordsReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListRecordsReplyMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListRecordsReplyMultiError) AllErrors() []error { return m }

// ListRecordsReplyValidationError is the validation error returned by
// ListRecordsReply.Validate if the designated constraints aren't met.
type ListRecordsReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListRecordsReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListRecordsReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListRecordsReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListRecordsReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListRecordsReplyValidationError) ErrorName() string { return "ListRecordsReplyValidationError" }

// Error satisfies the builtin error interface
func (e ListRecordsReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListRecordsReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListRecordsReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListRecordsReplyValidationError{}

// Validate checks the field values on BillingRecord with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *BillingRecord) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BillingRecord with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in BillingRecordMultiError, or
// nil if none found.
func (m *BillingRecord) ValidateAll() error {
	return m.validate(true)
}

func (m *BillingRecord) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for ServiceName

	// no validation rules for Type

	// no validation rules for Amount

	// no validation rules for Count

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BillingRecordValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BillingRecordValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BillingRecordValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return BillingRecordMultiError(errors)
	}

	return nil
}

// BillingRecordMultiError is an error wrapping multiple validation errors
// returned by BillingRecord.ValidateAll() if the designated constraints
// aren't met.
type BillingRecordMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BillingRecordMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BillingRecordMultiError) AllErrors() []error { return m }

// BillingRecordValidationError is the validation error returned by
// BillingRecord.Validate if the designated constraints aren't met.
type BillingRecordValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BillingRecordValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BillingRecordValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BillingRecordValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BillingRecordValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BillingRecordValidationError) ErrorName() string { return "BillingRecordValidationError" }

// Error satisfies the builtin error interface
func (e BillingRecordValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBillingRecord.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BillingRecordValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BillingRecordValidationError{}

// Validate checks the field values on CheckQuotaRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *CheckQuotaRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CheckQuotaRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CheckQuotaRequestMultiError, or nil if none found.
func (m *CheckQuotaRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CheckQuotaRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for UserId

	// no validation rules for ServiceName

	// no validation rules for Count

	if len(errors) > 0 {
		return CheckQuotaRequestMultiError(errors)
	}

	return nil
}

// CheckQuotaRequestMultiError is an error wrapping multiple validation errors
// returned by CheckQuotaRequest.ValidateAll() if the designated constraints
// aren't met.
type CheckQuotaRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CheckQuotaRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CheckQuotaRequestMultiError) AllErrors() []error { return m }

// CheckQuotaRequestValidationError is the validation error returned by
// CheckQuotaRequest.Validate if the designated constraints aren't met.
type CheckQuotaRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CheckQuotaRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CheckQuotaRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CheckQuotaRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CheckQuotaRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CheckQuotaRequestValidationError) ErrorName() string {
	return "CheckQuotaRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CheckQuotaRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCheckQuotaRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CheckQuotaRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CheckQuotaRequestValidationError{}

// Validate checks the field values on CheckQuotaReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *CheckQuotaReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CheckQuotaReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CheckQuotaReplyMultiError, or nil if none found.
func (m *CheckQuotaReply) ValidateAll() error {
	return m.validate(true)
}

func (m *CheckQuotaReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Allowed

	// no validation rules for Reason

	if len(errors) > 0 {
		return CheckQuotaReplyMultiError(errors)
	}

	return nil
}

// CheckQuotaReplyMultiError is an error wrapping multiple validation errors
// returned by CheckQuotaReply.ValidateAll() if the designated constraints
// aren't met.
type CheckQuotaReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CheckQuotaReplyMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CheckQuotaReplyMultiError) AllErrors() []error { return m }

// CheckQuotaReplyValidationError is the validation error returned by
// CheckQuotaReply.Validate if the designated constraints aren't met.
type CheckQuotaReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CheckQuotaReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CheckQuotaReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CheckQuotaReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CheckQuotaReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CheckQuotaReplyValidationError) ErrorName() string { return "CheckQuotaReplyValidationError" }

// Error satisfies the builtin error interface
func (e CheckQuotaReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCheckQuotaReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CheckQuotaReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CheckQuotaReplyValidationError{}

// Validate checks the field values on DeductQuotaRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeductQuotaRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeductQuotaRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeductQuotaRequestMultiError, or nil if none found.
func (m *DeductQuotaRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeductQuotaRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for UserId

	// no validation rules for ServiceName

	// no validation rules for Count

	// no validation rules for Cost

	if len(errors) > 0 {
		return DeductQuotaRequestMultiError(errors)
	}

	return nil
}

// DeductQuotaRequestMultiError is an error wrapping multiple validation errors
// returned by DeductQuotaRequest.ValidateAll() if the designated constraints
// aren't met.
type DeductQuotaRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeductQuotaRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeductQuotaRequestMultiError) AllErrors() []error { return m }

// DeductQuotaRequestValidationError is the validation error returned by
// DeductQuotaRequest.Validate if the designated constraints aren't met.
type DeductQuotaRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeductQuotaRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeductQuotaRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeductQuotaRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeductQuotaRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeductQuotaRequestValidationError) ErrorName() string {
	return "DeductQuotaRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeductQuotaRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeductQuotaRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeductQuotaRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeductQuotaRequestValidationError{}

// Validate checks the field values on DeductQuotaReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *DeductQuotaReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeductQuotaReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeductQuotaReplyMultiError, or nil if none found.
func (m *DeductQuotaReply) ValidateAll() error {
	return m.validate(true)
}

func (m *DeductQuotaReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Success

	// no validation rules for RecordId

	if len(errors) > 0 {
		return DeductQuotaReplyMultiError(errors)
	}

	return nil
}

// DeductQuotaReplyMultiError is an error wrapping multiple validation errors
// returned by DeductQuotaReply.ValidateAll() if the designated constraints
// aren't met.
type DeductQuotaReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeductQuotaReplyMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeductQuotaReplyMultiError) AllErrors() []error { return m }

// DeductQuotaReplyValidationError is the validation error returned by
// DeductQuotaReply.Validate if the designated constraints aren't met.
type DeductQuotaReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeductQuotaReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeductQuotaReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeductQuotaReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeductQuotaReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeductQuotaReplyValidationError) ErrorName() string { return "DeductQuotaReplyValidationError" }

// Error satisfies the builtin error interface
func (e DeductQuotaReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeductQuotaReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeductQuotaReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeductQuotaReplyValidationError{}

// Validate checks the field values on RechargeCallbackRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RechargeCallbackRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RechargeCallbackRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RechargeCallbackRequestMultiError, or nil if none found.
func (m *RechargeCallbackRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *RechargeCallbackRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for OrderId

	// no validation rules for PaymentOrderId

	// no validation rules for Amount

	// no validation rules for Status

	if len(errors) > 0 {
		return RechargeCallbackRequestMultiError(errors)
	}

	return nil
}

// RechargeCallbackRequestMultiError is an error wrapping multiple validation
// errors returned by RechargeCallbackRequest.ValidateAll() if the designated
// constraints aren't met.
type RechargeCallbackRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RechargeCallbackRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RechargeCallbackRequestMultiError) AllErrors() []error { return m }

// RechargeCallbackRequestValidationError is the validation error returned by
// RechargeCallbackRequest.Validate if the designated constraints aren't met.
type RechargeCallbackRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RechargeCallbackRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RechargeCallbackRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RechargeCallbackRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RechargeCallbackRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RechargeCallbackRequestValidationError) ErrorName() string {
	return "RechargeCallbackRequestValidationError"
}

// Error satisfies the builtin error interface
func (e RechargeCallbackRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRechargeCallbackRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RechargeCallbackRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RechargeCallbackRequestValidationError{}

// Validate checks the field values on RechargeCallbackReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RechargeCallbackReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RechargeCallbackReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RechargeCallbackReplyMultiError, or nil if none found.
func (m *RechargeCallbackReply) ValidateAll() error {
	return m.validate(true)
}

func (m *RechargeCallbackReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Success

	if len(errors) > 0 {
		return RechargeCallbackReplyMultiError(errors)
	}

	return nil
}

// RechargeCallbackReplyMultiError is an error wrapping multiple validation
// errors returned by RechargeCallbackReply.ValidateAll() if the designated
// constraints aren't met.
type RechargeCallbackReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RechargeCallbackReplyMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RechargeCallbackReplyMultiError) AllErrors() []error { return m }

// RechargeCallbackReplyValidationError is the validation error returned by
// RechargeCallbackReply.Validate if the designated constraints aren't met.
type RechargeCallbackReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RechargeCallbackReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RechargeCallbackReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RechargeCallbackReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RechargeCallbackReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RechargeCallbackReplyValidationError) ErrorName() string {
	return "RechargeCallbackReplyValidationError"
}

// Error satisfies the builtin error interface
func (e RechargeCallbackReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRechargeCallbackReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RechargeCallbackReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RechargeCallbackReplyValidationError{}
